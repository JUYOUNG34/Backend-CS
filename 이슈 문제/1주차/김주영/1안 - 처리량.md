## 처리량이란?

- 단위 시간 동안 시스템이 처리할 수 있는 요청 또는 작업의 수
- 표현 단위 : TPS(Transaction Per Second)나 RPS(Request Per Second)

### TPS(Transaction Per Second)

- 초당 처리된 **트랜잭션의 수**

<aside>
💡
트랜잭션이란?

- 데이터베이스 등에서 하나의 논리적인 작업 단위를 말함
  EX) 사용자가 상품을 구매 → 결제 , 재고 감소 , 영수증 발급 등 여러 작업이 포함된
  하나의 트랜잭션 (완료되면 TPS 1 up)
</aside>

### RPS(Request Per Second)

- 초당 처리된 **요청(Get,Post 등)** 의 수
- 트랜잭션보다 더 세분화된 단위

EX)  사용자 로그인 요청 → RPS 1 + 상품 리스트 요청 → RPS 1 + 장바구니 담기 요청 → RPS 1    =  TPS 1 (구매 트랜잭션)

### TPS 측정 방법

- **모니터링 도구** 활용
    - 예: 스카우터, 핀포인트, 뉴렐릭 등
    - 실시간 및 특정 시점의 TPS를 확인 가능
    - TPS 분석을 통해 성능 병목 구간 파악 및 개선 가능

**요약**

- 웹 서버라면 → 초당 몇 개의 HTTP 요청을 처리했는가 (RPS)
- 데이터베이스라면 → 초당 몇 개의 트랜잭션이 커밋되었는가 (TPS)
- TPS가 낮거나 초과되면 응답 지연이 발생할 수 있으므로, 이를 모니터링하고 조절하는 것이 시스템 성능 개선의 핵심

## • 처리량을 향상시키기 위해 시스템 설계에서 고려할 수 있는 방법은 어떤 것이 있나요?

## **1. 병목 제거 및 자원 분산**

- TPS 초과 시 병목 구간에서 지연 발생 → **병목 지점(전체 속도를 느리게만드는 가장 느린 부분)**을 찾아 해결하는 것이 핵심
- DB 성능 개선 , API 연동 최적화 , 네트워크 I/O 줄이기 등 병목 제거 필요

## **2. 수평 확장 (스케일 아웃)**

- 서버를 여러 대 추가하여 부하를 분산

        EX) 로드 밸런서를 활용하여 서버 클러스터링 

                웹 → 로드 밸런서 → 서버 여러 대 →  DB 구조

## **3. 수직 확장 (스케일 업)**

- 서버의 CPU , RAM , SSD 성능 향상
- 병렬 처리 능력을 키워 TPS 증가

## 4. DB 커넥션 풀

- DB 연결/종료 반복으로 인한 네트워크 오버헤드를 줄임
- 커넥션을 재사용하여 응답 시간 단축 및 처리량 향상

<aside>
💡 커넥션 풀이란?

- DB 연결을 매번 새로 생성/종료하는 비용은 매우 큼
- 커넥션 풀은 미리 일정 수의 DB 연결(커넥션)을 만들어 풀에 저장해두고 , 요청 시 즉시 커넥션을 재사용하도록 하는 기술

기존 방식: 요청마다 DB 연결 생성 → 쿼리 실행 → 연결 종료

커넥션 풀 방식: 풀에서 미리 연결된 커넥션을 꺼내 사용 → 다시 풀에 반환

</aside>

## **5. 캐시 사용**

- DB 접근을 줄이고 빠른 응답 제공 → TPS 향상
- 캐시 전략
- **로컬 캐시 / 분산 캐시(Redis) / CDN 캐시**

       - **읽기 캐시 , 쓰기 캐시 , 적중률 높이기 위한 TTL 조정**

- **API 캐시 , DB 쿼리 캐시 , 정적 자산 브라우저 캐시** 등 계층별로 활용 가능

| 항목 | **로컬 캐시 (Local Cache)** | **리모트 캐시 (Remote Cache)** |
| --- | --- | --- |
| **정의** | 서버 **프로세스 내부 메모리**에 캐시를 저장 | 서버 외부의 **별도 캐시 서버**에 캐시를 저장 |
| **속도** | 매우 빠름 (메모리 접근) | 상대적으로 느림 (네트워크 통신 필요) |
| **접근 방식** | 동일 프로세스 내에서 직접 접근 → 네트워크 불필요 | 네트워크를 통해 원격 캐시 서버에 접근 |
| **데이터 공유** | 서버마다 **독립적** → 서버 간 데이터 공유 어려움 | 여러 서버 간 **공통 데이터 공유** 가능 |
| **확장성** | 메모리에 의존하여 확장 한계 존재 | **수평 확장 가능** (레디스 클러스터 등) |
| **장점** | 빠른 응답 속도외부 의존성 없음구현 간단 | 서버 간 캐시 공유 가능데이터 일관성 유지 유리 |
| **단점** | 서버 재시작 시 캐시 초기화서버 간 일관성 어려움메모리 제한 존재 | 속도 느림,네트워크 지연 및 장애 가능성 있음 |
| **사용 예** | 인기 게시글, 설정값 등 자주 바뀌지 않는 소규모 데이터 | 상품 목록, 세션, 공통 설정 등 서버 간 공유 필요한 데이터 |
| **대표 기술** | Caffeine(Java), go-cache(Go), node-cache(Node.js) | Redis, Memcached 등 |

## **6. CDN (Content Delivery Network) 활용**

- 정적 리소스(이미지 , JS , CSS 등)을 전 세계 CDN 노드에 분산
- 사용자의 요청을 가장 가까운 위치에서 처리 → 네트워크 지연 최소화
- CDN은 **백엔드 서버 부하를 줄여 처리량 향상**에 크게 기여

       EX) Cloudflare , Akamai , Amazon CloudFront



## 7. **정적 자원(정적 자산) 캐싱 및 압축**

- 클라이언트(브라우저) 캐시 사용(Cache-Control, ETag 설정)
- gzip, Brotli 압축 사용 → 데이터 전송량 줄여 처리 속도 향상

<aside>
💡
정적 자원이란 ?

- 자주 바뀌지 않는 리소스들 [ HTML , CSS , JS , 이미지 , 폰트 , 영상 등 ]
- 웹 페이지 로딩 시 브라우저가 먼저 요청하게 되는 파일들
</aside>



## HTTP 캐시 생명 주기 관리

> [Toss Tech 실무 사례 참고](https://toss.tech/article/smart-web-service-cache)

### 📌 캐시 설정 주요 항목

####  max-age
- **캐시 유효 기간을 초 단위로 지정**  
  EX) `max-age=31536000` → 1년 동안 재요청 없이 캐시 사용

- **재검증(C revalidation)**: 캐시가 만료되면 `If‑None‑Match`(ETag) 또는 `If‑Modified‑Since`(Last‑Modified) 조건부 요청 실행. 304 응답으로 데이터 전송 최소화
- **no-cache , no-store**

      - `no-cache`: 저장은 하는데, 매 요청마다 서버에 재검증

      - `no-store`: 아예 저장 금지 (보안 정보 등)

- **public/private, s-maxage**:
    - `public`: CDN 포함 중간 캐시 가능
    - `private`: 브라우저 전용 캐시
    - `s-maxage=31536000, max-age=0`: 브라우저는 매번 재검증, CDN은 장기 캐시

### Nginx를 이용한 정적 콘텐츠 캐시 & 프록시 캐시

```
location ~* \.(jpg|jpeg|png|gif)$ { // 이미지 30일 캐시
  expires 30d;
  add_header Cache-Control public;
}

location ~* \.(css|js)$ { // CSS/JS : 7일 캐시
  expires 7d;
  add_header Cache-Control public;
}
```

### 프록시 캐싱 (리버스 프록시 / WAS 앞단)


```
proxy_cache_path /cache levels=1:2 keys_zone=my_cache:10m max_size=10g 
                                                          inactive=60m;
proxy_cache my_cache;
proxy_cache_valid 200 1d; // 200응답은 하루
proxy_cache_valid any 5m; // 그 외 상태는 5분 동안 유지
proxy_cache_use_stale error timeout updating http_500-504; // 에러 발생 시 이전 캐시
proxy_ignore_headers Set-Cookie;
```

### Gzip 압축 설정
```
gzip on;
gzip_comp_level 5;
gzip_min_length 256;
gzip_types text/plain text/css application/javascript application/json;
gzip_proxied any;
gzip_vary on;
gzip_disable "MSIE [1-6]\.(?!.*SV1)";
```

- 텍스트 리소스 압축 적용

## 8. **대기열(Queue) 전략)**

- 갑작스러운 요청 폭주 또는 외부 API의 TPS 제한이 있을 경우, 요청을 **큐(Queue)**에 저장한 뒤, 백엔드 서버가 **일정 속도로 순차 처리**하는 방식
- 병렬 처리나 동시성이 어려운 작업, TPS 제한된 외부 API 연동 시 유용함
- 예: 메시지 큐(RabbitMQ, Kafka, Amazon SQS 등) 도입 → 시스템의 안정적 처리량 확보

> 📌 참고: [IBM 메시지 큐 소개](https://www.ibm.com/kr-ko/think/topics/message-queues)

### 💼 실무 적용 예시

**금융 서비스 시나리오**
- 사용자의 송금/결제 승인 요청을 메시지 큐에 먼저 저장
- 백엔드가 순차적으로 처리 → TPS 초과, API 차단 방지